// class Solution {
// public:
//     // In 2 choices, 1st choice will be lower case 2nd choice will be upper case
//     void solve(string ip,string op,vector<string>&ans){
//         if(ip.length() == 0){
//             ans.push_back(op);
//             return;
//         }
//         string op1 = op;
//         string op2 = op;
//         op1 += tolower(ip[0]);
//         op2 += toupper(ip[0]);
//         ip.erase(ip.begin());
//         solve(ip,op1,ans);
//         solve(ip,op2,ans);
//         return;
//     }
//     vector<string> letterCasePermutation(string s) {
//         string op = "";
//         vector<string>ans;
//         solve(s,op,ans);
//         set<string>st(ans.begin(),ans.end());
//         vector<string>ans1(st.begin(),st.end());
//         return ans1;
//     }
// };

// Tried to optimize extra set solution but was not able to come up with a working solution, got this from ChatGPT
// class Solution {
// public:
//     void solve(string ip, string op, vector<string> &ans) {
//         if (ip.empty()) {
//             ans.push_back(op);
//             return;
//         }

//         // Consume consecutive digits together
//         int i = 0;
//         while (i < ip.size() && isdigit(ip[i])) {
//             op.push_back(ip[i]);
//             i++;
//         }

//         // Remove those digits from ip
//         ip.erase(ip.begin(), ip.begin() + i);

//         if (ip.empty()) {
//             ans.push_back(op);
//             return;
//         }

//         // Now ip[0] is a letter
//         string op1 = op, op2 = op;
//         op1.push_back(tolower(ip[0]));
//         op2.push_back(toupper(ip[0]));

//         ip.erase(ip.begin());
//         solve(ip, op1, ans);
//         solve(ip, op2, ans);
//     }

//     vector<string> letterCasePermutation(string s) {
//         vector<string> ans;
//         solve(s, "", ans);
//         return ans;
//     }
// };

// Better approach without needing an extra set container
class Solution {
public:
    // At each step:
    // Choice 1 → keep the character's current case
    // Choice 2 → flip the character's case (using bitwise XOR with ' ')
    void solve(string ip, string op, vector<string> &ans) {
        if (ip.size() == 0) {
            ans.push_back(op);
            return;
        }

        if (isalpha(ip[0])) {
            string op1 = op;
            string op2 = op;

            op1 += ip[0];           // Choice 1: use the character as-is
            op2 += (ip[0] ^ ' ');   // Choice 2: toggle the case using bitwise XOR

            ip.erase(ip.begin());   // Move to next character

            solve(ip, op1, ans);
            solve(ip, op2, ans);
        } else {
            // If the current character is a digit, just append and move ahead
            op += ip[0];
            ip.erase(ip.begin());
            solve(ip, op, ans);
        }
    }

    vector<string> letterCasePermutation(string s) {
        string op = "";
        vector<string> ans;
        solve(s, op, ans);
        return ans;
    }
};
