class Solution {
public:
    char findKthBit(int n, int k) {
        if(k == 1 || n == 1)return '0'; // Base case as given in description
        int len = (pow(2,n) - 1); // Length of the current row
        if(k <= (pow(2,n-1) - 1)){ // kth element will be the same as in previous row since current row is the same up until pow(2,n-1) - 1 elements
            return findKthBit(n-1,k);
        }
        else if(k==(pow(2,n-1))){ // kth element will be '1' since '1' is concatenated after every row
            return '1';
        }
        else{ // kth element will be inverse of (len - k + 1)th element if the previous row since after '1' concatenation we flip the elements of previous row and concatenate it in a reversed fashion to the current row string
            return findKthBit(n-1,len - k + 1) ^ 1; // Taking len - k + 1 removes the need for reversing the previous row
        }
    }
};
